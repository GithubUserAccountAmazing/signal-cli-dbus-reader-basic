#!/bin/bash
# basic template for setting up a signal-cli bot.
# Requires signal-cli: https://github.com/AsamK/signal-cli

# Uncomment the signal-cli username & daemon command on lines 116,117
#   or add the commands to your startup scripts.


# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.



examineMsg() {  # [1:TIMESTAMP] [2:SENDER] [3:MESSAGE] [4:CONTENT_TYPE] [5:FILENAME] 
		#                                                       
                #  from here you can easily do whatever you want with the message!   
                #  helpful commands:                                                 
                # 	                                                             
	 	#	signal-cli --dbus sendReceipt -t "$1" --type read "$2"       
	 	#	signal-cli --dbus sendTyping "$2"                            
	 	#	signal-cli --dbus send -m "$3" "$2"		             
		#	                                                             
		
	echo "TIMESTAMP: $1"
	echo "SENDER: $2"
	echo "MESSAGE: $3" | sed -e 's/\\n/\n         /g'
	echo "CONTENT TYPE: $4"
	echo "FILE NAME: $5"

	i=0 
}

signalRead() {  # [1:$i] [2:$dbus] 

	if [[ $1 == 1 ]]; then

		SENDER=$(echo "$2" | grep -oP '(?<=\").*(?=\")')
		i=$((i+1))

	elif [[ $1 == 2 ]] && [[ "$2" == "$msgStart"* ]]; then
		
		MESSAGE+="${2:8}\n"
		i=$((i+1))
		
	elif [[ $1 == 3 ]] && [[ "$2" != "$msgEnd"* ]]; then

		MESSAGE+="$2\n"

	elif [[ $1 == 3 ]] && [[ "$2" == "$msgEnd"* ]]; then
		
		#remove final quotation mark and trailing spaces
		MESSAGE="${MESSAGE%\"*}"
		i=$((i+1))
		
	elif [[ $1 == 4 ]] && [[ "$2" == "$contentAlert"* ]]; then
	
		att=True

	elif [[ $att == True ]] && [[ "$2" == "$variantLine"* ]]; then

		CONTENT_TYPE=$(echo "$2" | grep -oP '(?<=\").*(?=\")')
		att=False; i=$((i+1))
		
	elif [[ $1 == 5 ]] && [[ "$2" == "$fileAlert"* ]]; then

		getfile=True
	
	elif [[ $getfile == True ]] && [[ "$2" == "$variantLine"* ]]; then
		
		FILENAME=$(echo "$2" | grep -oP '(?<=\").*(?=\")')
		getfile=False; i=$((i+1))
	
	elif [[ "$2" == "$lastLine"* ]]; then

		examineMsg "$TIMESTAMP" "$SENDER" "$MESSAGE" "$CONTENT_TYPE" "$FILENAME"

	fi

}

#---------------------------------------

# this is the directory where signal stores you attachments
declare -r signalAttDir="/home/$USER/.local/share/signal-cli/attachments"

declare -r interface="org.asamk.Signal"
declare -r member="MessageReceivedV2"

# the variables below are used to distinguish the dbus strings containing relevant data. 
# the values of these variables may need to be changed in the future depending on future signal updates
declare -r signalNew="int64"
declare -r msgStart="string "
declare -r msgEnd="array ["
declare -r contentAlert="string \"contentType\""
declare -r fileAlert="string \"remoteId\""
declare -r variantLine="variant"
declare -r lastLine="string \"expiresInSeconds\""

#---------------------------------------

declare -i TIMESTAMP
declare -i att
declare -i getfile
declare -i i=0 

#declare -r USERNAME="+xxxxxxxxxxx"
#signal-cli -u "$USERNAME" daemon &> "/dev/null" &

clear; echo -e "\n ----- signal-bot ----- \n"

dbus-monitor --session "type='signal',interface='$interface', member='$member'" | 

	while read -r dbus; do
		
		# after retrieving a new message timestamp: $i > 0
		if [[ $i -gt 0 ]]; then
		
			# reads and extracts subsequent lines for message data.
			signalRead $i "$dbus"

		# signals that a new message has appeared in the dbus.
		elif [[ "$dbus" == "$signalNew"* ]]; then

			# reset all variables before reading the rest of the dbus lines.
			MESSAGE=""; CONTENT_TYPE=""; FILENAME=""
			att=False; getfile=False
			
			# this line also contains the timestamp of the message, 
			# the first 6 characters are removed before logging.
			TIMESTAMP="${dbus:6}"
			
			# increase i by one to allow for the signalRead function to begin.
			
			i=$((i+1))

		fi

	done
