#!/bin/bash

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#---------------------------------------------------------------------------

# basic template for setting up a signal-cli bot.
# Requires signal-cli: https://github.com/AsamK/signal-cli
# dedicated VM highly recommended :)

# Make sure you have started the daemon in your start up scripts using
# declare -r USERNAME="+xxxxxxxxxxx"
# signal-cli -u "$USERNAME" daemon &> "/dev/null" &

# Helpful signal-cli commands to use
# signal-cli --dbus sendReceipt -t "$1" --type read "$2"       
# signal-cli --dbus sendTyping "$2"                            
# signal-cli --dbus send -m "$3" "$2"	

# Define the important dbus substrings to search for
s="int64"
ms="string "
me="array ["
c="string \"contentType\""
f="string \"remoteId\""
v="variant"
l="string \"expiresInSeconds\""

# Define the interface and member for the Signal dbus signal
interface="org.asamk.Signal"
member="MessageReceivedV2"

# Take the signal message and print it in a formatted way
examineMsg() {
	local msg=$(sed 's/\\n/\\n     /g' <<<$3) 
	printf "TIME: %s\\nSENDER: %s\\nMSG: %b\\nCONTENT TYPE: %s\\nFILE NAME: %s\\n" \
	"$1" "$2" "$msg" "$4" "$5"
}

# Update the global variables that store the message information by 
# searching for the dbus substrings defined above. Manipulate the strings
# so that only relevant substrings are passed to the examineMsg function
readMsg() {
	case $1 in
  		0) t="${2:6}" ;; # set timestamp
		1) a="${2#*\"}" ; a="${a%\"*}" ;; # set SENDER
		2) case "$2" in 
			"$ms"*) b="${2:8}\n" ;; # set MSG
			*) j=$((j-1)) ;; esac ;;
		3) case "$2" in # if needed, used to add multiple lines to MSG
			"$me"*) b="${b%\"*}" ;;
			*) b+="$2\n" && j=$((j-1)) ;; esac ;;
		4) case "$d $2" in # if needed, set CONTENT TYPE 
			"false $c"*) d=true && j=$((j-1)) ;;
			"true $v"*) e="${2#*\"}" ; e="${e%\"*}" ;;
			 *) j=$((j-1)) ;; esac ;;
		5) case "$g $2" in # if needed, set FILE NAME
			"false $f"*) g=true && j=$((j-1)) ;;
			"true $v"*) h="${2#*\"}" ; h="${h%\"*}" ;;
			 *) j=$((j-1)) ;; esac ;;
	esac; [[ "$2" == "$l"* ]] && examineMsg "$t" "$a" "$b" "$e" "$h"
}

# Clear the terminal screen and then run a dbus-monitor command that listens for 
# new signal messages. Pipe the output to a while loop that reads each 
# line of the dbus and pass it to the readMsg function.
clear
dbus-monitor --session "type='signal',interface='$interface', member='$member'" |  
while read -r dbus; do
	[[ "$dbus" == "$s"* ]] && { j=0; b=""; e=""; h=""; d=false; g=false; } # reset variables when new message is received
	readMsg $j "$dbus"
	((j++))
done






